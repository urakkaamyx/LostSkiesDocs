// Copyright (c) coherence ApS.
// See the license file in the package root for more information.

namespace Coherence.Editor.Toolkit
{
    using System;
    using System.Collections.Generic;
    using System.Text.RegularExpressions;
    using System.IO;
    using System.Linq;
    using Coherence.Toolkit;
    using Log;
    using UnityEditor;
    using UnityEditor.SceneManagement;
    using UnityEditorInternal;
    using UnityEngine;
    using Logger = Log.Logger;
    using Object = UnityEngine.Object;

    [CustomEditor(typeof(CoherenceSync))]
    internal partial class CoherenceSyncEditor : BaseEditor
    {
        private static partial class GUIStyles
        {
            public static readonly GUIStyle bigButton = new(ContentUtils.GUIStyles.bigButton);

            public static readonly GUIStyle button = new(EditorStyles.miniButton)
            {
                fixedHeight = 25,
            };

            public static readonly GUIStyle buttonDirty = new(button)
            {
                fontStyle = FontStyle.Bold,
            };
        }

        private static partial class GUIContents
        {
            public static readonly GUIContent uuidLabel = EditorGUIUtility.TrTextContent("Manual Unique ID",
                "If left empty, the UUID will be autogenerated at runtime. Make sure this UUID is not used by any other networked GameObject.");

            public static readonly GUIContent replacementStrategyLabel = EditorGUIUtility.TrTextContent(
                "Replacement Strategy",
                "What should happen locally when the unique entity already exists on the server. The correct choice depends on whether the objects needs to move between scenes or not.");

            public static readonly GUIContent remoteEntityResolutionPriorityLabel = EditorGUIUtility.TrTextContent(
                "Remote Entity Resolution Priority",
                "Use either the Asset Id from the CoherenceSyncConfig or the Unique Id from the Prefab instance to relate instances of this Prefab to Remote Network Entities.");

            public static readonly GUIContent scenePrefabInstanceUuid =
                EditorGUIUtility.TrTextContent("Prefab Instance Unique ID",
                    "ID to uniquely identify prefab instances that are serialized in the scene.");

            public static readonly GUIContent isGlobalLabel =
                EditorGUIUtility.TrTextContent("Is Global",
                    "Setting this global makes this object visible to global queries.");

            public static readonly GUIContent interpolationLocationLabel =
                EditorGUIUtility.TrTextContent("Interpolate On",
                    "The event function in which the interpolation will be performed. `FixedUpdate` will be used for Rigidbody interpolation.");

            public static readonly GUIContent rigidbodyUpdateModeLabel = EditorGUIUtility.TrTextContent(
                "Rigidbody Update Mode",
                "The means by which the rigidbody of a replicated entity is updated. `Interpolated` uses the MovePosition / MoveRotation methods, `Direct` directly sets the position and rotation property.");

            public static readonly GUIContent orphanAdoption = EditorGUIUtility.TrTextContent("Auto-adopt Orphan",
                "With `auto-adopt orphan` enabled, other connected clients are able to start simulating this object automatically when it becomes orphaned (i.e. the client simulating it disconnects).");

            public static readonly GUIContent tagLabel = EditorGUIUtility.TrTextContent("Tag",
                "Adding a `tag` makes this object visible to any clients with a `TagQuery` using the corresponding tag.");

            public static readonly GUIContent preserveChildrenLabel =
                EditorGUIUtility.TrTextContent("Preserve Children",
                    "When enabled, entities parented to this entity are not destroyed when this entity is destroyed.");

            public static readonly GUIContent bakedScript = EditorGUIUtility.TrTextContent("Baked",
                "Full range of features. However, editing variables or methods at runtime is not allowed.");

            public static readonly GUIContent bakeNow = EditorGUIUtility.TrTextContent("Bake");

            public static readonly GUIContent requiresBaking = EditorGUIUtility.TrTextContentWithIcon(
                "Bake required in order to network this entity properly.", Icons.GetPath("Coherence.Bake.Warning"));

            public static readonly GUIContent notMappedPrefabMode =
                EditorGUIUtility.TrTextContent(
                    "CoherenceSync currently works only with prefabs.\nDrag this GameObject into a folder to create a prefab.");

            public static readonly GUIContent floatingOriginMode = new("Floating Origin Mode",
                "What happens to the Entity when it is a Root Object in the scene hierarchy.\n\nMove With Floating Origin: When you change your floating origin, the Entity is moved with it, so its relative position is the same and absolute position is shifted." +
                "\n\nDon't Move With Floating Origin: When you change your floating origin, the Entity is left behind, so its absolute position is the same and relative position is shifted.");

            public static readonly GUIContent floatingOriginParentedMode = new("Floating Origin Parented Mode",
                "What happens to the Entity when it is parented under another non-synced GameObject.\n\nMove With Floating Origin: When you change your floating origin, the Entity is moved with it, so its relative position is the same and absolute position is shifted." +
                "\n\nDon't Move With Floating Origin: When you change your floating origin, the Entity is left behind, so its absolute position is the same and relative position is shifted.");

            public static readonly GUIContent approveRequests =
                EditorGUIUtility.TrTextContent("Approve Requests", "Automatically approve authority requests.");

            public static readonly GUIContent sectionNetworkEntry =
                EditorGUIUtility.TrTextContent("How should we handle remote networked objects?");

            public static readonly GUIContent sectionBehaviour =
                EditorGUIUtility.TrTextContent("How will the networked object behave?");

            public static readonly GUIContent sectionBindings =
                EditorGUIUtility.TrTextContent("What is synchronized over the network?");

            public static readonly GUIContent subscribeTo = EditorGUIUtility.TrTextContent("Subscribe to...");
            public static readonly GUIContent sectionAdvanced = EditorGUIUtility.TrTextContent("Advanced Settings");
            public static readonly GUIContent sectionEvents = EditorGUIUtility.TrTextContent("Events");

            public static readonly GUIContent inputScriptAdded = EditorGUIUtility.TrTextContent("Input script added");

            public static readonly GUIContent syncGroupAdded =
                EditorGUIUtility.TrTextContent("Prefab Sync Group script added");

            public static readonly GUIContent selectBindings =
                EditorGUIUtility.TrTextContentWithIcon("Configure", Icons.GetPath("Coherence.Wizard"));

            public static readonly GUIContent optimize =
                EditorGUIUtility.TrTextContentWithIcon("Optimize", Icons.GetPath("Coherence.Optimize"));

            public static readonly GUIContent cantSetupInstance =
                EditorGUIUtility.TrTextContentWithIcon(
                    $"{nameof(CoherenceSync)} cannot be edited from Prefab instances. If you wish to edit this Component, please select the original Prefab Asset.",
                    "console.infoicon.sml");

            public static readonly GUIContent cantSetupInContextMode =
                EditorGUIUtility.TrTextContentWithIcon(
                $"{nameof(CoherenceSync)} cannot be edited in Context Mode yet. If you wish to edit this Component, please open in the prefab in Isolation instead.",
                "console.infoicon.sml");

            public static readonly GUIContent selectPrefabAsset =
                EditorGUIUtility.TrTextContentWithIcon("Open Prefab Asset", "Prefab Icon");

            public static readonly GUIContent syncPrefabStage =
                EditorGUIUtility.TrTextContentWithIcon("Sync Prefab Stage", Icons.GetPath("Coherence.Sync"));

            public static readonly GUIContent openPrefabInIsolation =
                EditorGUIUtility.TrTextContentWithIcon("Open Prefab In Isolation", "Prefab Icon");

            public static readonly GUIContent prefabModeReadMode =
                EditorGUIUtility.TrTextContent("Read more about Prefab Mode");

            public static readonly GUIContent selectPrefabStage =
                EditorGUIUtility.TrTextContentWithIcon("Select in Prefab Stage", "Prefab Icon");

            public static readonly GUIContent selectPrefabStageDescription =
                EditorGUIUtility.TrTextContentWithIcon("The Prefab Asset cannot be edited while it is also open in Prefab Stage.", "Info");

            public static readonly GUIContent coherenceSyncNotRoot = EditorGUIUtility.TrTextContent(
                $"{nameof(CoherenceSync)} should be at the root of the Prefab. If you need to sync any child values, first add {nameof(CoherenceSync)} to the root, then select the child and use the Configuration Window.");

            public static readonly GUIContent deleteCoherenceSync =
                EditorGUIUtility.TrTextContent("Delete CoherenceSync");

            public static readonly GUIContent bakeMissingScript =
                EditorGUIUtility.TrTextContent("Bake", "The baked implementation for this object is missing.");

            public static readonly GUIContent findMonoScript = EditorGUIUtility.TrTextContent("Find Script in Assets");

            public static readonly GUIContent infoOnBeforeNetworkedInstantiation =
                EditorGUIUtility.TrTextContent(
                    "Fired for all networked instances before initial component updates are applied");

            public static readonly GUIContent infoOnNetworkedInstantiation =
                EditorGUIUtility.TrTextContent(
                    "Fired for all networked instances after networked data is fully initialized");

            public static readonly GUIContent infoOnNetworkedDestruction =
                EditorGUIUtility.TrTextContent("When the networked entity is destroyed");

            public static readonly GUIContent infoOnInputSimulatorConnected =
                EditorGUIUtility.TrTextContent(
                    "Fired on client when simulator is ready (Server-Side with Client Input). Might be also raised for simulator or client-host if they have both input and state authority.");

            public static readonly GUIContent infoOnStateAuthorityGainedProperty =
                EditorGUIUtility.TrTextContent("Fired when gain state authority over the entity");

            public static readonly GUIContent infoOnInputAuthorityGainedProperty =
                EditorGUIUtility.TrTextContent("Fired when gain input authority over the entity");

            public static readonly GUIContent infoOnStateAuthorityLostProperty =
                EditorGUIUtility.TrTextContent("Fired when lose state authority over the entity");

            public static readonly GUIContent infoOnInputAuthorityLostProperty =
                EditorGUIUtility.TrTextContent("Fired when lose input authority over the entity");

            public static readonly GUIContent infoOnAuthorityRequestRejectedProperty =
                EditorGUIUtility.TrTextContent("When we receive a rejection of authority transfer");

            public static readonly GUIContent infoOnRigidbody2DPositionUpdateProperty =
                EditorGUIUtility.TrTextContent("When the rigidbody 2D position would be manually updated");

            public static readonly GUIContent infoOnRigidbody3DPositionUpdateProperty =
                EditorGUIUtility.TrTextContent("When the rigidbody 3D position would be manually updated");

            public static readonly GUIContent infoOnRigidbody2DRotationUpdateProperty =
                EditorGUIUtility.TrTextContent("When the rigidbody 2D rotation would be manually updated");

            public static readonly GUIContent infoOnRigidbody3DRotationUpdateProperty =
                EditorGUIUtility.TrTextContent("When the rigidbody 3D rotation would be manually updated");

            public static readonly GUIContent script = EditorGUIUtility.TrTextContent("Script");

            public static readonly GUIContent bakeScriptReady =
                EditorGUIUtility.TrTextContentWithIcon("Using generated baked script.", "Installed");

            public static readonly GUIContent bakedScriptNotFound =
                EditorGUIUtility.TrTextContentWithIcon("Baked script code not found. Bake to fix.", "Warning");

            public static readonly GUIContent notIncludedInSchema =
                EditorGUIUtility.TrTextContentWithIcon("Prefab is not included in Schema and it won't be baked.",
                    "Warning");

            public static readonly GUIContent prefabSetupLink = new("Learn more about Prefab setup here");

            public static readonly GUIContent prefabNotFound = EditorGUIUtility.TrTextContentWithIcon(
                $"Prefab not present in {nameof(CoherenceSyncConfigRegistry)}.", "Warning");

            public static readonly GUIContent stageOutOfSync = EditorGUIUtility.TrTextContentWithIcon(
                $"The Stage is out-of-sync. Click the 'Sync Prefab Stage' button below.", "Info");

            public static readonly GUIContent prefabInstanceHasUndesiredOverrides =
                EditorGUIUtility.TrTextContent("Fix Prefab Instance");

            public static readonly GUIContent prefabInstanceHasUndesiredOverridesDescription =
                EditorGUIUtility.TrTextContentWithIcon("This Prefab Instance contains overrides that might make it unusable.",
                    "Warning");
        }

        private static readonly Logger logger = Log.GetLogger<CoherenceSyncEditor>();

        private Type bakedType;
        private MonoScript bakedScript;

        private CoherenceSync sync;

        [SerializeField]
        private UnitySyncEvents SyncEvents = new();

        [Serializable]
        protected class UnitySyncEvents
        {
            [SerializeField]
            internal UnityEventInfo[] SyncEvents;

            internal void Init(SerializedObject serializedObject)
            {
                SyncEvents = new UnityEventInfo[]
                {
                    new(serializedObject.FindProperty("onBeforeNetworkedInstantiation"),
                        GUIContents.infoOnBeforeNetworkedInstantiation),
                    new(serializedObject.FindProperty("onNetworkedInstantiation"),
                        GUIContents.infoOnNetworkedInstantiation),
                    new(serializedObject.FindProperty("onNetworkedDestruction"),
                        GUIContents.infoOnNetworkedDestruction),
                    new(serializedObject.FindProperty(nameof(CoherenceSync.OnInputSimulatorConnected)),
                        GUIContents.infoOnInputSimulatorConnected),
                    new(serializedObject.FindProperty(nameof(CoherenceSync.OnStateAuthority)),
                        GUIContents.infoOnStateAuthorityGainedProperty),
                    new(serializedObject.FindProperty(nameof(CoherenceSync.OnStateRemote)),
                        GUIContents.infoOnStateAuthorityLostProperty),
                    new(serializedObject.FindProperty(nameof(CoherenceSync.OnInputAuthority)),
                        GUIContents.infoOnInputAuthorityGainedProperty),
                    new(serializedObject.FindProperty(nameof(CoherenceSync.OnInputRemote)),
                        GUIContents.infoOnInputAuthorityLostProperty),
                    new(serializedObject.FindProperty(nameof(CoherenceSync.OnAuthorityRequestRejected)),
                        GUIContents.infoOnAuthorityRequestRejectedProperty, true),
                    new(serializedObject.FindProperty(nameof(CoherenceSync.OnRigidbody2DPositionUpdate)),
                        GUIContents.infoOnRigidbody2DPositionUpdateProperty),
                    new(serializedObject.FindProperty(nameof(CoherenceSync.OnRigidbody3DPositionUpdate)),
                        GUIContents.infoOnRigidbody3DPositionUpdateProperty),
                    new(serializedObject.FindProperty(nameof(CoherenceSync.OnRigidbody2DRotationUpdate)),
                        GUIContents.infoOnRigidbody2DRotationUpdateProperty),
                    new(serializedObject.FindProperty(nameof(CoherenceSync.OnRigidbody3DRotationUpdate)),
                        GUIContents.infoOnRigidbody3DRotationUpdateProperty),
                };
            }

            internal void Dispose()
            {
                foreach (var item in SyncEvents)
                {
                    item.Dispose();
                }

                SyncEvents = null;
            }
        }

        [Serializable]
        protected class UnityEventInfo
        {
            public bool Shown;
            public SerializedProperty prop;
            private GUIContent content;
            private bool obsolete;

            public UnityEventInfo(SerializedProperty prop, GUIContent content, bool obsolete = false)
            {
                this.prop = prop;
                this.content = content;
                this.obsolete = obsolete;
            }

            public bool IsShown => Shown || HaveSubscriptions;
            public bool HaveSubscriptions => prop.FindPropertyRelative("m_PersistentCalls.m_Calls")?.arraySize > 0;
            public bool AllowShow => HaveSubscriptions || !obsolete;

            internal void Dispose()
            {
                prop.Dispose();
            }

            internal void RemoveAllSubscriptions()
            {
                var p = prop.FindPropertyRelative("m_PersistentCalls.m_Calls");
                p.serializedObject.Update();
                p.ClearArray();
                _ = p.serializedObject.ApplyModifiedProperties();
            }

            internal void Draw(Object target)
            {
                using (var relativeProp = prop.FindPropertyRelative("m_PersistentCalls.m_Calls"))
                {
                    if (relativeProp?.arraySize > 0 || Shown)
                    {
                        EditorGUILayout.LabelField(content, ContentUtils.GUIStyles.centeredGreyMiniLabelWrap);
                        DrawEvent(prop, relativeProp, target);
                    }
                }
            }

            private void DrawEvent(SerializedProperty eventProperty, SerializedProperty calls, Object target)
            {
                EditorGUI.BeginChangeCheck();
                _ = EditorGUILayout.PropertyField(eventProperty);
                if (EditorGUI.EndChangeCheck())
                {
                    for (var i = 0; i < calls.arraySize; i++)
                    {
                        var targetProperty = calls.GetArrayElementAtIndex(i).FindPropertyRelative("m_Target");
                        if (!targetProperty.objectReferenceValue)
                        {
                            targetProperty.objectReferenceValue = target;
                        }
                    }
                }
            }
        }

        private SerializedProperty coherenceSyncConfigProperty;
        private SerializedProperty networkObjectEntry;
        private SerializedObject serializedGameObject;
        private SerializedProperty componentsProperty;
        private SerializedProperty interpolationLocationProperty;
        private SerializedProperty rigidbodyUpdateModeProperty;
        private SerializedProperty simulationTypeProperty;
        private SerializedProperty authorityTransferTypeProperty;
        private SerializedProperty orphanedBehaviorProperty;
        private SerializedProperty globalProperty;
        private SerializedProperty tagProperty;
        private SerializedProperty preserveChildrenProperty;
        private SerializedProperty lifetimeTypeProperty;
        private SerializedProperty uniquenessTypeProperty;
        private SerializedProperty approveAuthorityTransferRequestsProperty;
        private SerializedProperty coherenceUUIDProperty;
        private SerializedProperty replacementStrategyProperty;
        private SerializedProperty unsyncedEntityPriorityProperty;
        private SerializedProperty scenePrefabInstanceUUIDProperty;
        private SerializedProperty floatingOriginModeProperty;
        private SerializedProperty floatingOriginParentedModeProperty;
        private SerializedProperty bakedScriptTypeProperty;

        private GameObjectStatus gameObjectStatus;
        private List<(string UUID, bool Unique)> UuidList;

        private bool GameObjectIsInstanceInScene => gameObjectStatus is { IsInstanceInScene: true } or
        { IsNestedInstanceInsideAnotherPrefab: true };

        protected override void OnEnable()
        {
            base.OnEnable();

            sync = target as CoherenceSync;

            if (!sync)
            {
                return;
            }

            CheckPrefabStatus();

            EditorApplication.modifierKeysChanged += Repaint;

            serializedGameObject = new SerializedObject(sync.gameObject);
            componentsProperty = serializedGameObject.FindProperty("m_Component");

            coherenceSyncConfigProperty = serializedObject.FindProperty("coherenceSyncConfig");
            interpolationLocationProperty = serializedObject.FindProperty("interpolationLocation");
            rigidbodyUpdateModeProperty = serializedObject.FindProperty(nameof(CoherenceSync.RigidbodyUpdateMode));
            simulationTypeProperty = serializedObject.FindProperty("simulationType");
            authorityTransferTypeProperty = serializedObject.FindProperty("authorityTransferType");
            orphanedBehaviorProperty = serializedObject.FindProperty("orphanedBehavior");
            globalProperty = serializedObject.FindProperty("isGlobal");
            tagProperty = serializedObject.FindProperty("coherenceTag");
            preserveChildrenProperty = serializedObject.FindProperty(nameof(CoherenceSync.preserveChildren));
            lifetimeTypeProperty = serializedObject.FindProperty("lifetimeType");
            uniquenessTypeProperty = serializedObject.FindProperty("uniquenessType");
            approveAuthorityTransferRequestsProperty =
                serializedObject.FindProperty("approveAuthorityTransferRequests");
            coherenceUUIDProperty = serializedObject.FindProperty("coherenceUUID");
            replacementStrategyProperty = serializedObject.FindProperty("replacementStrategy");
            unsyncedEntityPriorityProperty = serializedObject.FindProperty("unsyncedNetworkEntityPriority");
            scenePrefabInstanceUUIDProperty = serializedObject.FindProperty("scenePrefabInstanceUUID");
            floatingOriginModeProperty = serializedObject.FindProperty(nameof(CoherenceSync.floatingOriginMode));
            floatingOriginParentedModeProperty =
                serializedObject.FindProperty(nameof(CoherenceSync.floatingOriginParentedMode));

            SyncEvents.Init(serializedObject);

            bakedScriptTypeProperty = serializedObject.FindProperty("bakedScriptType");

            _ = serializedObject.ApplyModifiedPropertiesWithoutUndo();

            bakedType = Type.GetType(bakedScriptTypeProperty.stringValue);
            if (bakedType != null && !Application.isPlaying)
            {
                FindMonoScript();
            }
        }

        private void FindMonoScript()
        {
            if (!Directory.Exists(Paths.defaultSchemaBakePath))
            {
                return;
            }

            var asset = AssetDatabase.FindAssets($"{bakedType.Name} t:MonoScript", new[]
            {
                Paths.defaultSchemaBakePath,
            });

            if (asset.Length == 1)
            {
                var path = AssetDatabase.GUIDToAssetPath(asset[0]);
                bakedScript = AssetDatabase.LoadAssetAtPath<MonoScript>(path);
            }
        }

        protected override void OnDisable()
        {
            base.OnDisable();

            interpolationLocationProperty.Dispose();
            rigidbodyUpdateModeProperty.Dispose();
            simulationTypeProperty.Dispose();
            authorityTransferTypeProperty.Dispose();
            orphanedBehaviorProperty.Dispose();
            globalProperty.Dispose();
            tagProperty.Dispose();
            preserveChildrenProperty.Dispose();
            lifetimeTypeProperty.Dispose();
            uniquenessTypeProperty.Dispose();
            replacementStrategyProperty.Dispose();
            unsyncedEntityPriorityProperty.Dispose();
            approveAuthorityTransferRequestsProperty.Dispose();

            SyncEvents.Dispose();

            bakedScriptTypeProperty.Dispose();
            componentsProperty.Dispose();

            serializedGameObject.Dispose();

            EditorApplication.modifierKeysChanged -= Repaint;
        }

        internal static string GetBakedScriptFullTypeName(CoherenceSync sync)
        {
            var name = GetBakedScriptTypeName(sync);
            return string.IsNullOrEmpty(name)
                ? null
                : $"Coherence.Generated.{GetBakedScriptTypeName(sync)}, Assembly-CSharp";
        }

        private static string GetBakedScriptTypeName(CoherenceSync sync)
        {
            // We're trying to locate the Prefab Asset
            var prefab = GetPrefab(sync.gameObject);
            if (!prefab)
            {
                prefab = sync.gameObject;
            }

            if (!prefab)
            {
                return default;
            }

            // It could be the case that we're on a Prefab Instance,
            // and the Prefab Asset doesn't contain a CoherenceSync
            if (!prefab.TryGetComponent(out CoherenceSync originalSync))
            {
                return default;
            }

            return SchemaCreator.BakedScriptName(originalSync);
        }

        private void DrawViewOnlyMode()
        {
            if (gameObjectStatus is { IsRootOfPrefabStageHierarchy: true, PrefabStageMode: PrefabStageMode.InContext })
            {
                _ = EditorGUILayout.BeginVertical(GUI.skin.box);
                EditorGUILayout.LabelField(GUIContents.cantSetupInContextMode, ContentUtils.GUIStyles.richMiniLabel);
                OpenPrefabInIsolationButton();
                EditorGUILayout.EndVertical();
                return;
            }


            if (GameObjectIsInstanceInScene)
            {
                _ = EditorGUILayout.BeginVertical(GUI.skin.box);
                EditorGUILayout.LabelField(GUIContents.cantSetupInstance, ContentUtils.GUIStyles.richMiniLabel);
                SelectPrefabAssetButton();
                EditorGUILayout.EndVertical();
            }
        }

        private void DrawNotPrefabMode()
        {
            _ = EditorGUILayout.BeginVertical(GUI.skin.box);
            EditorGUILayout.LabelField(GUIContents.notMappedPrefabMode, ContentUtils.GUIStyles.centeredGreyMiniLabelWrap,
                GUILayout.MinHeight(60));
            var go = sync.gameObject;
            if (GUILayout.Button("Convert to Prefab in Resources", GUILayout.Height(32)))
            {
                if (gameObjectStatus.PrefabInstanceStatus != PrefabInstanceStatus.NotAPrefab)
                {
                    PrefabUtility.UnpackPrefabInstance(go, PrefabUnpackMode.OutermostRoot, InteractionMode.UserAction);
                }

                if (!Directory.Exists("Assets/Resources"))
                {
                    _ = AssetDatabase.CreateFolder("Assets", "Resources");
                }

                var path = AssetDatabase.GenerateUniqueAssetPath($"Assets/Resources/{go.name}.prefab");
                var prefabGo =
                    PrefabUtility.SaveAsPrefabAssetAndConnect(go, path, InteractionMode.UserAction, out var success);
                if (success)
                {
                    Selection.activeGameObject = prefabGo;
                }
            }

            if (GUILayout.Button("Convert to Prefab in Assets", GUILayout.Height(32)))
            {
                if (gameObjectStatus.PrefabInstanceStatus != PrefabInstanceStatus.NotAPrefab)
                {
                    PrefabUtility.UnpackPrefabInstance(go, PrefabUnpackMode.OutermostRoot, InteractionMode.UserAction);
                }

                var path = AssetDatabase.GenerateUniqueAssetPath($"Assets/{go.name}.prefab");
                var prefabGo =
                    PrefabUtility.SaveAsPrefabAssetAndConnect(go, path, InteractionMode.UserAction, out var success);
                if (success)
                {
                    Selection.activeGameObject = prefabGo;
                }
            }

            if (GUILayout.Button("Convert to Prefab in...", GUILayout.Height(32)))
            {
                if (gameObjectStatus.PrefabInstanceStatus != PrefabInstanceStatus.NotAPrefab)
                {
                    PrefabUtility.UnpackPrefabInstance(go, PrefabUnpackMode.OutermostRoot, InteractionMode.UserAction);
                }

                var path = EditorUtility.SaveFilePanel("Create Prefab", "Assets", go.name, "prefab");
                if (!string.IsNullOrEmpty(path) && path.StartsWith(Application.dataPath))
                {
                    path = "Assets" + path.Substring(Application.dataPath.Length);
                    var prefabGo =
                        PrefabUtility.SaveAsPrefabAssetAndConnect(go, path, InteractionMode.UserAction,
                            out var success);
                    if (success)
                    {
                        Selection.activeGameObject = prefabGo;
                    }
                }

                GUIUtility.ExitGUI();
            }

            EditorGUILayout.EndVertical();
        }

        protected override void OnGUI()
        {
            if (!sync)
            {
                sync = target as CoherenceSync;
            }

            CheckPrefabStatus();

            if (ProcessIllegalHierarchy())
            {
                return;
            }

            serializedObject.Update();

            var stage = PrefabStageUtility.GetCurrentPrefabStage();
            if (stage && stage.assetPath == AssetDatabase.GetAssetPath(sync))
            {
                EditorGUILayout.BeginVertical(GUI.skin.box);
                EditorGUILayout.LabelField(GUIContents.selectPrefabStageDescription, ContentUtils.GUIStyles.richMiniLabel);
                PrefabButton(GUIContents.selectPrefabStage);
                EditorGUILayout.EndVertical();
            }

            if (CoherenceSyncUtils.HasUndesiredOverrides(sync))
            {
                EditorGUILayout.BeginVertical(GUI.skin.box);
                EditorGUILayout.LabelField(GUIContents.prefabInstanceHasUndesiredOverridesDescription,
                    ContentUtils.GUIStyles.miniLabel);
                if (GUILayout.Button(GUIContents.prefabInstanceHasUndesiredOverrides, GUIStyles.bigButton))
                {
                    if (CoherenceSyncUtils.RemoveUndesiredOverrides(sync, InteractionMode.UserAction) > 0)
                    {
                        serializedObject.Update();
                        _ = serializedObject.ApplyModifiedProperties();
                    }

                    // Rebuild the Inspector so that bakedScript can be recreated, in case it was overridden.
                    ActiveEditorTracker.sharedTracker.ForceRebuild();
                    GUIUtility.ExitGUI();
                }
                EditorGUILayout.EndVertical();
            }

            if (!gameObjectStatus.IsAsset && Application.isPlaying)
            {
                DrawPlaymode();
            }

            if (!Application.isPlaying && !gameObjectStatus.IsAsset)
            {
                if (!gameObjectStatus.IsInstanceInScene ||
                    gameObjectStatus.PrefabInstanceStatus != PrefabInstanceStatus.Connected)
                {
                    DrawNotPrefabMode();
                    return;
                }
            }

            if (GUI.enabled)
            {
                DrawViewOnlyMode();

                if (!BakeUtil.BakeOnBuild || !BakeUtil.BakeOnEnterPlayMode)
                {
                    DrawBakeWarning();
                }
            }

            DrawSectionBindings();
            DrawNetworkEntrySection();
            DrawSectionBehaviour();
            DrawSectionAdvanced();
            DrawEventSelection();

            if (serializedObject.ApplyModifiedProperties())
            {
                BakeUtil.CoherenceSyncSchemasDirty = true;
            }
        }

        private void CheckPrefabStatus()
        {
            gameObjectStatus = new GameObjectStatus(sync.gameObject);
        }

        private void DrawBakeWarning()
        {
            if (CloneMode.Enabled)
            {
                return;
            }

            if (BakeUtil.Outdated)
            {
                _ = EditorGUILayout.BeginVertical(GUI.skin.box);
                EditorGUILayout.LabelField(GUIContents.requiresBaking, ContentUtils.GUIStyles.miniLabel);
                if (!Application.isPlaying)
                {
                    if (GUILayout.Button(GUIContents.bakeNow, GUIStyles.button))
                    {
                        BakeUtil.Bake();
                    }
                }

                EditorGUILayout.EndVertical();
            }
        }

        private void DrawBindingStats()
        {
            var entryInfo = CoherenceSyncConfigUtils.GetBindingInfo(sync).Value;
            var lods = sync.Archetype.LODLevels.Count;

            _ = EditorGUILayout.BeginHorizontal();
            var maxWidth = EditorGUIUtility.labelWidth;

            _ = EditorGUILayout.BeginVertical(GUILayout.Width(maxWidth));
            using (var property = serializedObject.FindProperty("bindings"))
            {
                DrawVariables(entryInfo.Variables, property);
                DrawMethods(entryInfo.Methods, property);
            }

            DrawNetworkComponents(entryInfo.NetworkComponents);

            EditorGUILayout.EndVertical();

            _ = EditorGUILayout.BeginVertical(GUILayout.Width(maxWidth));

            using (var property = serializedObject.FindProperty(nameof(CoherenceSync.componentActions)))
            {
                DrawComponentActions(entryInfo.ComponentActions, property);
            }

            if (entryInfo.Bits > 0)
            {
                var c = new GUIContent($"<color=grey>Max bandwidth</color> {entryInfo.Bits} bits",
                    "Maximum amount of bits sent over the network coming from state changes on this object (per network tick).");
                GUILayout.Label(c, ContentUtils.GUIStyles.richMiniLabel);
            }

            if (lods > 1)
            {
                GUILayout.Label($"<color=grey>Levels of Detail</color> {lods}", ContentUtils.GUIStyles.richMiniLabel);
            }

            EditorGUILayout.EndVertical();
            EditorGUILayout.EndHorizontal();

            if (IsEditingBindingsAllowed(sync))
            {
                NetworkObjectsInfoDrawer.DrawInvalidBindings(entryInfo.InvalidBindings, OnPerformedAction);
                NetworkObjectsInfoDrawer.DrawBindingsWithInputAuthorityPrediction(sync,
                    entryInfo.BindingsWithInputAuthPrediction, OnPerformedAction);

                if (entryInfo.NetworkComponents > BakeUtil.MaxUniqueComponentsBound)
                {
                    CoherenceHubLayout.DrawErrorArea(
                        BakeUtil.GetTooManyNetworkComponentsErrorMessage(entryInfo.NetworkComponents));
                }

                if (gameObjectStatus.HasChildrenCoherenceSyncs && sync.GetComponent<PrefabSyncGroup>() == null)
                {
                    var content = EditorGUIUtility.TrTextContentWithIcon(
                        $"Prefab has {nameof(CoherenceSync)} children, but it lacks a PrefabSyncGroup Component to synchronize the hierarchy.",
                        string.Empty, "Warning");

                    EditorGUILayout.LabelField(content, ContentUtils.GUIStyles.richMiniLabel);

                    if (CoherenceHubLayout.DrawButton($"Add {nameof(PrefabSyncGroup)} Component"))
                    {
                        Undo.AddComponent<PrefabSyncGroup>(sync.gameObject);

                        if (EditorWindow.focusedWindow)
                        {
                            EditorWindow.focusedWindow.ShowNotification(GUIContents.syncGroupAdded);
                        }
                    }
                }
            }
        }

        private bool IsEditingBindingsAllowed(CoherenceSync sync) =>
            CoherenceSyncUtils.IsEditingBindingsAllowed(sync, InteractionMode.UserAction) && gameObjectStatus.PrefabInstanceStatus is PrefabInstanceStatus.Connected;

        private void OnPerformedAction() => Repaint();

        private static void DrawNetworkComponents(int networkComponents)
        {
            var content = EditorGUIUtility.TrTempContent(
                $"{networkComponents} <color=grey>network component{(networkComponents != 1 ? "s" : "")}</color>");
            var width = ContentUtils.GUIStyles.richMiniLabel.CalcSize(content).x + 2f;

            var style = ContentUtils.GUIStyles.richMiniLabel;
            var controlRect = EditorGUILayout.GetControlRect(false,
                style.CalcHeight(content, width),
                style, GUILayout.ExpandWidth(false));

            EditorGUI.LabelField(controlRect, content, style);
        }

        private static void DrawComponentActions(int componentActions, SerializedProperty p)
        {
            var content = EditorGUIUtility.TrTempContent(
                $"{(componentActions != 0 ? componentActions.ToString() : "No")} <color=grey>component action{(componentActions != 1 ? "s" : "")}</color>");

            var style = ContentUtils.GUIStyles.richMiniLabel;
            var width = style.CalcSize(content).x;

            var controlRect = EditorGUILayout.GetControlRect(false,
                style.CalcHeight(content, width),
                style, GUILayout.ExpandWidth(false));

            GUI.Label(controlRect, content, style);
        }

        private static void DrawMethods(int methods, SerializedProperty p)
        {
            var content = EditorGUIUtility.TrTempContent(
                $"{(methods != 0 ? methods.ToString() : "No")} <color=grey>method{(methods != 1 ? "s" : "")}</color>");

            var style = ContentUtils.GUIStyles.richMiniLabel;
            var width = style.CalcSize(content).x;

            var controlRect = EditorGUILayout.GetControlRect(false,
                style.CalcHeight(content, width),
                style, GUILayout.ExpandWidth(false));

            GUI.Label(controlRect, content, style);
        }

        private static void DrawVariables(int variables, SerializedProperty p)
        {
            var content = EditorGUIUtility.TrTempContent(
                $"{(variables != 0 ? variables.ToString() : "No")} <color=grey>variable{(variables != 1 ? "s" : "")}</color>");

            var style = ContentUtils.GUIStyles.richMiniLabel;
            var width = style.CalcSize(content).x;

            var controlRect = EditorGUILayout.GetControlRect(false,
                style.CalcHeight(content, width),
                style, GUILayout.ExpandWidth(false));

            GUI.Label(controlRect, content, style);
        }

        private void DrawBindingActions()
        {
            _ = EditorGUILayout.BeginHorizontal();
            DrawConfigureButton();
            DrawOptimizeButton();
            EditorGUILayout.EndHorizontal();

            void DrawConfigureButton()
            {
                if (GUILayout.Button(GUIContents.selectBindings,
                        OverrideActions.HasOverrides(sync) ? GUIStyles.buttonDirty : GUIStyles.button))
                {
                    CoherenceSyncBindingsWindow w;
                    if (Event.current.modifiers == EventModifiers.Alt)
                    {
                        w = CoherenceSyncBindingsWindow.GetWindowDocked(target as CoherenceSync);
                    }
                    else
                    {
                        w = CoherenceSyncBindingsWindow.GetWindow(target as CoherenceSync);
                    }

                    w.scope = CoherenceSyncBindingsWindow.Scope.Variables;

                    ReportAnalytic("configure");
                }
            }

            void DrawOptimizeButton()
            {
                if (GUILayout.Button(GUIContents.optimize, GUIStyles.button))
                {
                    BindingsWindow.Init();
                    ReportAnalytic("optimize");
                }
            }
        }

        private void DrawSectionBindings()
        {
            EditorGUILayout.LabelField(GUIContents.sectionBindings);

            _ = EditorGUILayout.BeginVertical(GUI.skin.box);
            DrawBindingStats();

            if (GUI.enabled)
            {
                EditorGUI.BeginDisabledGroup(ShouldDisableSection());
                EditorGUILayout.Separator();
                DrawBindingActions();
                EditorGUI.EndDisabledGroup();
            }

            EditorGUILayout.EndVertical();
        }

        private void DrawEventSelection()
        {
            EditorGUILayout.LabelField(GUIContents.sectionEvents);
            _ = EditorGUILayout.BeginVertical(GUI.skin.box);

            if (GUILayout.Button(GUIContents.subscribeTo))
            {
                OpenSubscribeToMenu();
            }

            foreach (var item in SyncEvents.SyncEvents)
            {
                item.Draw(target);
            }

            EditorGUILayout.EndVertical();

            void OpenSubscribeToMenu()
            {
                var menu = new GenericMenu();
                foreach (var item in SyncEvents.SyncEvents.Where(x => x.AllowShow))
                {
                    var content = new GUIContent(item.prop.displayName);
                    var shown = item.IsShown;
                    menu.AddItem(content, shown,
                        () =>
                        {
                            if (!shown)
                            {
                                ReportAnalytic("register_unity_event", item.prop);
                            }

                            if (shown && item.HaveSubscriptions)
                            {
                                if (!EditorUtility.DisplayDialog("Remove All Subscriptions?",
                                        $"Are you sure you want to remove all subscriptions and hide event {content.text}?",
                                        "OK", "Cancel"))
                                {
                                    return;
                                }

                                item.RemoveAllSubscriptions();
                            }

                            item.Shown = !shown;
                        });
                }

                menu.ShowAsContext();
            }
        }

        private bool ShouldBeUnique =>
            uniquenessTypeProperty.intValue == (int)CoherenceSync.UniquenessType.NoDuplicates;

        private void DrawUniqueness()
        {
            if (!sync)
            {
                return;
            }

            EditorGUI.BeginDisabledGroup(ShouldDisableSection());

            EditorGUI.BeginChangeCheck();
            DrawCoherenceSyncProperty("Uniqueness", uniquenessTypeProperty);
            if (EditorGUI.EndChangeCheck())
            {
                var uniquenessType = (CoherenceSync.UniquenessType)uniquenessTypeProperty.intValue;
                ReportAnalytic("uniqueness_type", uniquenessType);
            }

            EditorGUI.EndDisabledGroup();

            EditorGUI.BeginDisabledGroup(ShouldDisableSection(Editability.NonRootPrefabs | Editability.InContextMode));
            EditorGUI.indentLevel++;
            DrawUUID();
            EditorGUI.indentLevel--;
            EditorGUI.EndDisabledGroup();
        }

        private bool advancedUuidFoldout;

        private void DrawUUID()
        {
            if (!ShouldBeUnique)
            {
                return;
            }

            using (new EditorGUI.DisabledScope(Application.isPlaying))
            {
                _ = EditorGUILayout.PropertyField(coherenceUUIDProperty, GUIContents.uuidLabel);
            }

            using (new EditorGUILayout.HorizontalScope())
            {
                using (new EditorGUI.DisabledScope(true))
                {
                    _ = EditorGUILayout.PropertyField(scenePrefabInstanceUUIDProperty,
                        GUIContents.scenePrefabInstanceUuid);
                }

                using var scope = new EditorGUI.DisabledScope(!gameObjectStatus.IsInstanceInScene);

                if (GUILayout.Button(CoherenceHubLayout.GUIContents.refresh, CoherenceHubLayout.Styles.Button,
                        GUILayout.Width(35f)))
                {
                    SyncPrefabInstanceUniqueId.SyncInstanceUpdated(sync,
                        serializedObject.FindProperty("m_GameObject.m_FileID").intValue, true);
                }
            }

            advancedUuidFoldout = EditorGUILayout.Foldout(advancedUuidFoldout, "Advanced Uniqueness Options");

            if (advancedUuidFoldout)
            {
                EditorGUI.indentLevel++;
                using (new EditorGUI.DisabledScope(ShouldDisableSection()))
                {
                    _ = EditorGUILayout.PropertyField(replacementStrategyProperty, GUIContents.replacementStrategyLabel);
                    _ = EditorGUILayout.PropertyField(unsyncedEntityPriorityProperty, GUIContents.remoteEntityResolutionPriorityLabel);
                }

                EditorGUI.indentLevel--;
            }
        }

        /// <summary>
        /// Gets a value indicating whether a section should be drawn as read-only or not.
        /// </summary>
        private bool ShouldDisableSection(Editability editability = Editability.Default)
        {
            if (!editability.HasFlag(Editability.InContextMode) && gameObjectStatus.PrefabStageMode is PrefabStageMode.InContext)
            {
                return true;
            }

            if (!editability.HasFlag(Editability.InPlayMode) && Application.isPlaying)
            {
                return true;
            }

            if (!editability.HasFlag(Editability.NonRootPrefabs) && !gameObjectStatus.IsRootOfAssetHierarchy)
            {
                return true;
            }

            if (!editability.HasFlag(Editability.WhileAlsoOpenInPrefabStage) && !gameObjectStatus.IsInPrefabStage && PrefabStageUtility.GetCurrentPrefabStage() is var prefabStage && prefabStage && prefabStage.assetPath == AssetDatabase.GetAssetPath(sync))
            {
                return true;
            }

            return false;
        }

        private bool ShouldDisableSyncProperty()
        {
            if (gameObjectStatus.IsInstanceInScene || gameObjectStatus.IsNestedInstanceInsideAnotherPrefab ||
                   !gameObjectStatus.IsAsset)
            {
                return true;
            }

            if (gameObjectStatus.IsInPrefabStage)
            {
                var prefabStage = PrefabStageUtility.GetPrefabStage(sync.gameObject);
                if (prefabStage && prefabStage.mode == PrefabStage.Mode.InContext)
                {
                    return true;
                }
            }
            else
            {
                var prefabStage = PrefabStageUtility.GetCurrentPrefabStage();
                if (prefabStage && prefabStage.assetPath == AssetDatabase.GetAssetPath(sync))
                {
                    return true;
                }
            }

            return false;
        }

        private void DrawSimulate()
        {
            EditorGUI.BeginDisabledGroup(ShouldDisableSection());

            var rect = EditorGUILayout.GetControlRect();
            DrawSimulateInternal(rect, sync, simulationTypeProperty, authorityTransferTypeProperty,
                true);
            EditorGUI.EndDisabledGroup();
        }

        internal static void DrawSimulateInternal(Rect rect, CoherenceSync sync,
            SerializedProperty simulationTypeProperty, SerializedProperty authorityTransferTypeProperty, bool useLabel)
        {
            EditorGUI.BeginChangeCheck();

            var content = useLabel ? new GUIContent("Simulate in") : GUIContent.none;

            _ = EditorGUI.PropertyField(rect, simulationTypeProperty, content);

            if (EditorGUI.EndChangeCheck())
            {
                var simulationType = (CoherenceSync.SimulationType)simulationTypeProperty.intValue;
                ReportAnalytic("simulation_type", simulationType);

                var useInput = simulationTypeProperty.intValue ==
                               (int)CoherenceSync.SimulationType.ServerSideWithClientInput;

                if (useInput)
                {
                    authorityTransferTypeProperty.intValue = (int)CoherenceSync.AuthorityTransferType.Stealing;

                    if (sync.gameObject.TryGetComponent(out CoherenceInput input))
                    {
                        input.enabled = true;
                    }
                    else
                    {
                        input = Undo.AddComponent<CoherenceInput>(sync.gameObject);
                        if (EditorWindow.focusedWindow)
                        {
                            EditorWindow.focusedWindow.ShowNotification(GUIContents.inputScriptAdded);
                        }
                    }

                    if (authorityTransferTypeProperty.serializedObject != simulationTypeProperty.serializedObject)
                    {
                        _ = authorityTransferTypeProperty.serializedObject.ApplyModifiedProperties();
                    }

                    InternalEditorUtility.SetIsInspectorExpanded(input, true);
                }

                _ = simulationTypeProperty.serializedObject.ApplyModifiedProperties();

                if (useInput)
                {
                    GUIUtility.ExitGUI();
                }
            }
        }

        private static void DrawCoherenceSyncProperty(string label, SerializedProperty property)
        {
            _ = EditorGUILayout.PropertyField(property, new GUIContent(label));
        }

        private void DrawLifetime()
        {
            EditorGUI.BeginDisabledGroup(ShouldDisableSection());

            var rect = EditorGUILayout.GetControlRect();
            DrawLifetimeInternal(rect, lifetimeTypeProperty, authorityTransferTypeProperty, true);

            EditorGUI.EndDisabledGroup();


            if ((CoherenceSync.LifetimeType)lifetimeTypeProperty.intValue == CoherenceSync.LifetimeType.Persistent)
            {
                DrawOrphanAdoption();
            }
        }

        internal static void DrawLifetimeInternal(Rect rect, SerializedProperty lifetimeProperty,
            SerializedProperty authorityTransferProperty, bool useLabel)
        {
            using var change = new EditorGUI.ChangeCheckScope();
            var content = useLabel ? new GUIContent("Lifetime") : GUIContent.none;

            _ = EditorGUI.PropertyField(rect, lifetimeProperty, content);

            if (change.changed)
            {
                var lifetimeType = (CoherenceSync.LifetimeType)lifetimeProperty.intValue;
                ReportAnalytic("lifetime_type", lifetimeType);

                if ((CoherenceSync.LifetimeType)lifetimeProperty.intValue == CoherenceSync.LifetimeType.Persistent
                && (CoherenceSync.AuthorityTransferType)authorityTransferProperty.intValue ==
                CoherenceSync.AuthorityTransferType.NotTransferable)
                {
                    authorityTransferProperty.intValue = (int)CoherenceSync.AuthorityTransferType.Stealing;

                    if (authorityTransferProperty.serializedObject != lifetimeProperty.serializedObject)
                    {
                        _ = authorityTransferProperty.serializedObject.ApplyModifiedProperties();
                    }
                }

                _ = lifetimeProperty.serializedObject.ApplyModifiedProperties();
            }
        }

        private void DrawTransferAuthority()
        {
            var isLifetimePersistent = sync.lifetimeType == CoherenceSync.LifetimeType.Persistent;

            EditorGUI.BeginDisabledGroup(ShouldDisableSection() || sync.simulationType is CoherenceSync.SimulationType.ServerSideWithClientInput);
            {
                using var change = new EditorGUI.ChangeCheckScope();

                var previousValue = authorityTransferTypeProperty.intValue;

                EditorGUI.BeginChangeCheck();
                DrawCoherenceSyncProperty("Authority Transfer", authorityTransferTypeProperty);
                if (EditorGUI.EndChangeCheck())
                {
                    var authorityTransferType = (CoherenceSync.AuthorityTransferType)authorityTransferTypeProperty.intValue;
                    ReportAnalytic("authority_transfer_type", authorityTransferType);
                }

                if (change.changed && isLifetimePersistent && authorityTransferTypeProperty.intValue ==
                    (int)CoherenceSync.AuthorityTransferType.NotTransferable)
                {
                    logger.Info("Cannot set transfer authority to Disabled, since it's Lifetime is set to Persistent.");
                    authorityTransferTypeProperty.intValue = previousValue;
                }
            }

            EditorGUI.indentLevel++;
            if (sync.authorityTransferType == CoherenceSync.AuthorityTransferType.Request)
            {
                _ = EditorGUILayout.PropertyField(approveAuthorityTransferRequestsProperty,
                    GUIContents.approveRequests);
            }

            EditorGUI.indentLevel--;

            EditorGUI.EndDisabledGroup();
        }

        private void DrawNetworkEntrySection()
        {
            EditorGUILayout.Separator();
            EditorGUILayout.LabelField(GUIContents.sectionNetworkEntry);

            _ = EditorGUILayout.BeginVertical(GUI.skin.box);

            EditorGUI.BeginDisabledGroup(ShouldDisableSection(Editability.WhileAlsoOpenInPrefabStage | Editability.InPlayMode));

            DrawNetworkEntry();
            EditorGUI.EndDisabledGroup();

            EditorGUILayout.EndVertical();
        }

        private void DrawSectionBehaviour()
        {
            EditorGUILayout.Separator();
            EditorGUILayout.LabelField(GUIContents.sectionBehaviour);

            _ = EditorGUILayout.BeginVertical(GUI.skin.box);

            DrawSimulate();
            DrawLifetime();
            DrawUniqueness();
            DrawTransferAuthority();

            EditorGUILayout.EndVertical();
        }

        private void DrawNetworkEntry()
        {
            if (coherenceSyncConfigProperty.objectReferenceValue != null)
            {
                using (new EditorGUI.DisabledScope(true))
                {
                    EditorGUILayout.ObjectField(coherenceSyncConfigProperty);
                }

                if (sync.CoherenceSyncConfig.EditorTarget == null)
                {
                    var content = EditorGUIUtility.TrTextContentWithIcon("Fix Network Asset Entry",
                        "The related Network Asset Entry no longer has a reference for this object and it will be ignored. Press this button to fix it.",
                        "Warning");

                    if (GUILayout.Button(content))
                    {
                        CoherenceSyncConfigRegistry.Instance.ReimportConfigs();
                    }
                }

                using var configSerializedObject = new SerializedObject(coherenceSyncConfigProperty.objectReferenceValue);

                DrawPropertiesExcluding(configSerializedObject, "m_Script", "id", "selfId", "editorTarget");
                _ = configSerializedObject.ApplyModifiedProperties();
            }
            else
            {
                var style = ContentUtils.GUIStyles.miniLabel;
                if (gameObjectStatus.IsInPrefabStage)
                {
                    // The modifications made by CoherenceSyncPostProcessor.OnPostprocessAllAssets don't trigger a file hash
                    // calculation (AssetDatabase.GetSourceAssetFileHash stays the same throughout that callback), meaning
                    // changes done there (i.e., assigning a reference to the newly created CoherenceSync.CoherenceSyncConfig)
                    // are not detected by the Editor. This surfaces an issue where the Stage is not aware of the changes made
                    // to the Prefab Asset, hence it shows CoherenceSyncConfig is null (which is not).
                    // The hash gets recalculated once the Prefab Asset is selected. This looks like a Unity issue.
                    // There's no API that forces rehashing.
                    // https://issuetracker.unity3d.com/product/unity/issues/guid/UUM-62514

                    EditorGUILayout.LabelField(GUIContents.stageOutOfSync, style);

                    if (GUILayout.Button(GUIContents.syncPrefabStage, GUILayout.Height(32)))
                    {
                        var stage = PrefabStageUtility.GetPrefabStage(sync.gameObject);
                        var assetPath = stage.assetPath;
                        AssetDatabase.SaveAssetIfDirty(AssetDatabase.GUIDFromAssetPath(assetPath));

                        PrefabStageUtility.OpenPrefab(assetPath, null, PrefabStage.Mode.InIsolation);
                        var prefabStage = PrefabStageUtility.GetCurrentPrefabStage();
                        Selection.activeGameObject = prefabStage.prefabContentsRoot;
                    }
                }
                else
                {
                    EditorGUILayout.LabelField(GUIContents.prefabNotFound, style);

                    if (AssetDatabase.Contains(sync.gameObject))
                    {
                        if (GUILayout.Button("Register CoherenceSync"))
                        {
                            var config = CoherenceSyncConfigUtils.Create(sync.gameObject);
                            sync.CoherenceSyncConfig = config;
                            EditorUtility.SetDirty(sync);
                            GUIUtility.ExitGUI();
                        }
                    }
                }
            }
        }

        private void DrawInterpolation()
        {
            using (new EditorGUI.DisabledScope(Application.isPlaying))
            {
                EditorGUI.BeginChangeCheck();
                _ = EditorGUILayout.PropertyField(interpolationLocationProperty, GUIContents.interpolationLocationLabel);
                if (EditorGUI.EndChangeCheck())
                {
                    var interpolateOn = (CoherenceSync.InterpolationLoop)interpolationLocationProperty.intValue;
                    ReportAnalytic("interpolate_on", interpolateOn);
                    Event.current.Use();
                }

                if (interpolationLocationProperty.intValue == 0)
                {
                    EditorGUILayout.HelpBox(GUIContents.interpolationWarning);
                }

                EditorGUI.BeginChangeCheck();
                _ = EditorGUILayout.PropertyField(rigidbodyUpdateModeProperty, GUIContents.rigidbodyUpdateModeLabel);
                if (EditorGUI.EndChangeCheck())
                {
                    var rigidbodyUpdateMode = (CoherenceSync.RigidbodyMode)rigidbodyUpdateModeProperty.intValue;
                    ReportAnalytic("rigidbody_update_mode", rigidbodyUpdateMode);
                }
            }
        }

        private void DrawOrphanAdoption()
        {
            EditorGUI.indentLevel++;
            var rect = EditorGUILayout.GetControlRect(true, EditorGUIUtility.singleLineHeight, EditorStyles.toggle);
            var label = EditorGUI.BeginProperty(rect, GUIContents.orphanAdoption, orphanedBehaviorProperty);
            EditorGUI.BeginChangeCheck();
            using (new EditorGUI.DisabledScope(!sync.IsPersistent))
            {
                var sel = EditorGUI.Toggle(rect, label, orphanedBehaviorProperty.enumValueIndex != 0);
                if (EditorGUI.EndChangeCheck())
                {
                    orphanedBehaviorProperty.enumValueIndex = sel ? 1 : 0;
                }
            }

            EditorGUI.EndProperty();
            EditorGUI.indentLevel--;
        }

        private void DrawGlobal()
        {
            _ = EditorGUILayout.PropertyField(globalProperty, GUIContents.isGlobalLabel);
        }

        private void DrawTag()
        {
            _ = EditorGUILayout.PropertyField(tagProperty, GUIContents.tagLabel);
        }

        private void DrawPreserveChildren()
        {
            EditorGUI.BeginChangeCheck();
            _ = EditorGUILayout.PropertyField(preserveChildrenProperty, GUIContents.preserveChildrenLabel);
            if (EditorGUI.EndChangeCheck())
            {
                ReportAnalytic("preserve_children", preserveChildrenProperty.boolValue);
            }
        }

        private void DrawFloatingOriginMode()
        {
            EditorGUI.BeginChangeCheck();
            _ = EditorGUILayout.PropertyField(floatingOriginModeProperty, GUIContents.floatingOriginMode);
            if (EditorGUI.EndChangeCheck())
            {
                var worldOriginMode = (CoherenceSync.FloatingOriginMode)floatingOriginModeProperty.intValue;
                ReportAnalytic("world_origin_mode", worldOriginMode);
            }

            EditorGUI.BeginChangeCheck();
            _ = EditorGUILayout.PropertyField(floatingOriginParentedModeProperty, GUIContents.floatingOriginParentedMode);
            if (EditorGUI.EndChangeCheck())
            {
                var worldOriginParentedMode = (CoherenceSync.FloatingOriginMode)floatingOriginParentedModeProperty.intValue;
                ReportAnalytic("world_origin_parented_mode", worldOriginParentedMode);
            }
        }

        private void DrawSectionAdvanced()
        {
            EditorGUILayout.Separator();
            EditorGUILayout.LabelField(GUIContents.sectionAdvanced);

            _ = EditorGUILayout.BeginVertical(GUI.skin.box);

            DrawBakedScript();
            EditorGUI.BeginDisabledGroup(ShouldDisableSection(Editability.WhileAlsoOpenInPrefabStage | Editability.InPlayMode));
            DrawInterpolation();
            DrawGlobal();
            DrawTag();
            DrawPreserveChildren();
            DrawFloatingOriginMode();
            EditorGUI.EndDisabledGroup();

            EditorGUILayout.EndVertical();
        }

        private void DrawBakedScript()
        {
            if (sync.CoherenceSyncConfig != null && !sync.CoherenceSyncConfig.IncludeInSchema)
            {
                EditorGUILayout.LabelField(GUIContents.notIncludedInSchema, ContentUtils.GUIStyles.wrappedLabel);
            }
            else if (bakedScript)
            {
                if (!string.IsNullOrEmpty(bakedScript.name))
                {
                    EditorGUI.BeginDisabledGroup(true);
                    _ = EditorGUILayout.ObjectField(GUIContents.script, bakedScript, typeof(CoherenceSyncBaked),
                        false);
                    EditorGUI.EndDisabledGroup();
                }

                EditorGUILayout.LabelField(GUIContents.bakeScriptReady);
            }
            else if (bakedType != null)
            {
                if (ContentUtils.DrawButton(GUIContents.script, GUIContents.findMonoScript))
                {
                    FindMonoScript();
                    Repaint();
                }

                EditorGUILayout.LabelField(GUIContents.bakeScriptReady);
            }
            else
            {
                _ = EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField(GUIContents.bakedScriptNotFound, ContentUtils.GUIStyles.wrappedLabel);
                if (GUILayout.Button(GUIContents.bakeMissingScript, EditorStyles.miniButton))
                {
                    BakeUtil.Bake();
                    Repaint();
                }

                EditorGUILayout.EndHorizontal();
            }
        }

        private bool IsPrefabStage()
        {
            return StageUtility.GetCurrentStage() != StageUtility.GetMainStage();
        }

        private static GameObject GetPrefabAssetOfPrefabInstance(GameObject go)
        {
            var path = PrefabUtility.GetPrefabAssetPathOfNearestInstanceRoot(go);
            if (string.IsNullOrEmpty(path))
            {
                return go;
            }

            var asset = AssetDatabase.LoadAssetAtPath<GameObject>(path);
            return asset;
        }

        /// <summary>
        ///     Get the root of the prefab that this object is part of.
        ///     Note: Does not care about `CoherenceSync`.
        /// </summary>
        /// <returns>May return null if no prefab was found.</returns>
        internal static GameObject GetPrefab(GameObject obj)
        {
            if (obj == null)
            {
                return obj;
            }

            var prefabStage = PrefabStageUtility.GetPrefabStage(obj);

            if (prefabStage)
            {
                return AssetDatabase.LoadAssetAtPath<GameObject>(prefabStage.assetPath);
            }

            // asset
            if (AssetDatabase.Contains(obj))
            {
                return obj;
            }

            // in scene
            {
                var instanceRoot = PrefabUtility.GetNearestPrefabInstanceRoot(obj);
                if (instanceRoot)
                {
                    return GetPrefabAssetOfPrefabInstance(instanceRoot);
                }

                instanceRoot = PrefabUtility.GetOutermostPrefabInstanceRoot(obj);
                if (instanceRoot)
                {
                    return GetPrefabAssetOfPrefabInstance(instanceRoot);
                }

                return null;
            }
        }

        private bool ProcessIllegalHierarchy()
        {
            if (gameObjectStatus.IsRootOfAssetHierarchy
            || gameObjectStatus.IsNearestPrefabInstanceRoot
            || gameObjectStatus.IsRootOfInstanceHierarchy
            || gameObjectStatus.IsRootOfNonPrefabHierarchy
            || Application.isPlaying)
            {
                return false;
            }

            if (gameObjectStatus.IsInPrefabStage)
            {
                var prefabStage = PrefabStageUtility.GetPrefabStage(sync.gameObject);
                if (prefabStage && prefabStage.prefabContentsRoot == sync.gameObject)
                {
                    return false;
                }
            }

            CoherenceHubLayout.DrawErrorArea(GUIContents.coherenceSyncNotRoot.text);

            CoherenceHubLayout.DrawLink(GUIContents.prefabSetupLink,
                DocumentationLinks.GetDocsUrl(DocumentationKeys.PrefabSetup));

            EditorGUILayout.Space();

            if (GUILayout.Button(GUIContents.deleteCoherenceSync, ContentUtils.GUIStyles.bigButton) &&
                EditorUtility.DisplayDialog("Delete CoherenceSync", "Are you sure you want to delete the CoherenceSync component?", "Delete", "Cancel"))
            {
                CoherenceSyncUtils.DestroyCoherenceComponents(sync.gameObject);
                if (IsPrefabStage())
                {
                    EditorUtility.SetDirty(PrefabStageUtility.GetCurrentPrefabStage().prefabContentsRoot);
                }
                GUIUtility.ExitGUI();
            }

            return true;
        }

        private void OpenPrefabInIsolationButton()
        {
            PrefabButton(GUIContents.openPrefabInIsolation);
            CoherenceHubLayout.DrawLink(GUIContents.prefabModeReadMode, ExternalLinks.UnityDocsPrefabMode);
        }

        private void SelectPrefabAssetButton() => PrefabButton(GUIContents.selectPrefabAsset);

        private void PrefabButton(GUIContent label)
        {
            if (GUILayout.Button(label, GUIStyles.bigButton))
            {
                PrefabUtils.OpenInIsolation(sync.gameObject, gameObjectStatus, true);
            }
        }

        private class EventProperties : Analytics.BaseProperties
        {
            public string control_name;
            public string control_state;
        }

        private static string ToSnakeCase(string str) =>
            Regex.Replace(str, @"[A-Z0-9]([A-Z0-9](?![a-z]))*", "_$0")
                .TrimStart('_')
                .ToLowerInvariant();

        private static void ReportAnalytic(string controlName) => ReportAnalytic(controlName, "");
        private static void ReportAnalytic(string controlName, bool controlState) => ReportAnalytic(controlName, controlState ? "on" : "off");
        private static void ReportAnalytic<TEnum>(string controlName, TEnum controlState) where TEnum : Enum => ReportAnalytic(controlName, ToSnakeCase(controlState.ToString()));
        private static void ReportAnalytic(string controlName, SerializedProperty controlState) => ReportAnalytic(controlName, ToSnakeCase(controlState.name));

        private static void ReportAnalytic(string controlName, string controlState) =>
            Analytics.Capture(new Analytics.Event<EventProperties>(Analytics.Events.CoherenceSyncEditor,
                new EventProperties
                {
                    control_name = controlName ?? "",
                    control_state = controlState ?? "",
                }
            ));

        [Flags]
        private enum Editability
        {
            Default = 0,

            /// <summary>
            /// Allow editing in Prefab Stage in Context Mode?
            /// </summary>
            InContextMode = 1,

            /// <summary>
            /// Allow editing in Play Mode?
            /// </summary>
            InPlayMode = 2,

            /// <summary>
            /// Allow editing on instances that are not the root object of a prefab asset nor the root object open in prefab stage?
            /// </summary>
            NonRootPrefabs = 4,

            /// <summary>
            /// Allow editing via prefab asset when prefab is already being edited in the Prefab Stage?
            /// </summary>
            WhileAlsoOpenInPrefabStage = 8
        }
    }
}
