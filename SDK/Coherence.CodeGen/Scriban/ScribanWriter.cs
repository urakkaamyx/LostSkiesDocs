namespace Coherence.CodeGen
{
    using System;
    using System.IO;
    using Log;
    using Scriban;

    public class ScribanWriter
    {
        private static readonly Logger Logger = Log.GetLogger<ScribanWriter>();

        private TemplateContext context;

        public RenderResult Render(ScribanOptions options, string savePath, string fileName)
        {
            if (!RenderToText(options, out var result))
            {
                return new() { Success = false };
            }

            try
            {
                WriteResultToDisk(savePath, fileName, result);
                return new()
                {
                    Success = true,
                    FileGenerated = GetFilePath(savePath, fileName),
                };
            }
            catch (Exception e)
            {
                Logger.Error(Error.ScribanWriterError, e.Message);
                return new() { Success = false };
            }
        }

        internal bool RenderToText(ScribanOptions options, out string result)
        {
            var baseTemplate = GetBaseTemplate(options);

            var scribanTemplate = GetScribanTemplate(baseTemplate);

            BuildTemplateContext(options);

            try
            {
                result = ReplaceLineEndings(scribanTemplate.Render(context));
                return true;
            }
            catch (Exception e)
            {
                Logger.Error(Error.ScribanWriterError, e.Message);
                result = null;
                return false;
            }

            Template GetScribanTemplate(string baseTemplate)
            {
                var scribanTemplate = Template.Parse(baseTemplate);
                if (scribanTemplate.HasErrors)
                {
                    foreach (var error in scribanTemplate.Messages)
                    {
                        Logger.Error(Error.ScribanWriterError, error.Message);
                    }

                    Logger.Error(Error.ScribanTemplateError);
                }

                return scribanTemplate;
            }
        }

        private void WriteResultToDisk(string savePath, string fileName, string result)
        {
            try
            {
                File.WriteAllText(GetFilePath(savePath, fileName), result);
            }
            catch (PathTooLongException pathTooLongException)
            {
                Logger.Error(Error.ScribanWriterError, pathTooLongException.Message);
            }
            catch (DirectoryNotFoundException directoryNotFoundException)
            {
                Logger.Error(Error.ScribanWriterError, directoryNotFoundException.Message);
            }
        }

        private static string GetFilePath(string savePath, string fileName)
        {
            return Path.Combine(savePath, $"{fileName}.cs").Replace("\\", "/");
        }

        private void BuildTemplateContext(ScribanOptions options)
        {
            context ??= new TemplateContext();

            context.LoopLimit = 0;
            context.NewLine = Environment.NewLine;
            context.TemplateLoader =
                context.TemplateLoader == null || context.TemplateLoader.GetType() != options.TemplateLoader.GetType()
                    ? options.TemplateLoader
                    : context.TemplateLoader;

            // There is always one Global ScriptObject, which is the built in Scriban functions
            // https://github.com/scriban/scriban/blob/master/doc/runtime.md#the-builtin-functions
            while (context.GlobalCount > 1)
            {
                context.PopGlobal();
            }

            foreach (var model in options.Model)
            {
                context.PushGlobal(model);
            }
        }

        internal static string GetBaseTemplate(ScribanOptions options)
        {
            var writer = new StringWriter { NewLine = Environment.NewLine };

            writer.WriteLine("// Copyright (c) coherence ApS.");
            writer.WriteLine("// For all coherence generated code, the coherence SDK license terms apply. See the license file in the coherence Package root folder for more information.");
            writer.WriteLine();
            writer.WriteLine("// <auto-generated>");
            writer.WriteLine("// Generated file. DO NOT EDIT!");
            writer.WriteLine("// </auto-generated>");
            writer.Write("namespace ");
            writer.WriteLine(options.Namespace);
            writer.WriteLine('{');

            foreach (var directive in options.UsingDirectives)
            {
                writer.Write("    using ");
                writer.Write(directive);
                writer.WriteLine(';');
            }

            foreach (var template in options.TemplateNames)
            {
                writer.Write("{{ include '");
                writer.Write(template);
                writer.WriteLine("' }}");
            }

            writer.WriteLine('}');

            return writer.ToString();
        }

        /// <summary>
        /// Replaces all newline sequences in the current string with <see cref="Environment.NewLine"/>.
        /// </summary>
        private static string ReplaceLineEndings(string text)
        {
            if (Environment.NewLine is "\n")
            {
                return text.Replace("\r\n", "\n");
            }

            return text.Replace("\r\n", "\n").Replace("\n", Environment.NewLine);
        }
    }
}
